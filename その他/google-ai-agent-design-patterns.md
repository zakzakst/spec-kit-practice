---
url: https://docs.cloud.google.com/architecture/choose-design-pattern-agentic-ai-system?hl=ja
---

# エージェント AI システムの設計パターンを選択する

## 要件を定義する

下記の質問を出発点として、エージェント システムの主な目標を特定し、最適な設計パターンを選択します。

- **タスクの特性**: タスクは事前定義されたワークフローの手順で完了できますか？それとも、タスクはオープンエンドですか？タスクで AI モデルを使用してワークフローをオーケストレートする必要がありますか？
- **レイテンシとパフォーマンス**: 精度や高品質のレスポンスを犠牲にして、高速またはインタラクティブなレスポンスを優先する必要がありますか？または、より正確で徹底的な結果を得るために、アプリケーションで遅延を許容できますか？
- **費用**: 推論費用の予算はどれくらいですか？1 回のリクエストでモデルを複数回呼び出す必要があるパターンをサポートできますか？
- **人間の関与**: タスクに、リスクの高い意思決定、安全性が重要なオペレーション、人間の判断が必要な主観的な承認が含まれていますか？

---

## 単一エージェント システム

単一エージェント システムは、複数のステップと外部データへのアクセスを必要とするタスクに最適です。

エージェントの開発の初期段階では、単一のエージェントから始めることをおすすめします。単一エージェント システムでエージェント開発を開始すると、より複雑なアーキテクチャ コンポーネントを追加する前に、エージェントのコアロジック、プロンプト、ツール定義の調整に集中できます。

---

## マルチエージェント システム

マルチエージェント システムは、複数の特殊エージェントをオーケストレートして、単一のエージェントでは簡単に管理できない複雑な問題を解決します。基本的な原則は、大きな目標を小さなサブタスクに分解し、特定のスキルを持つ専用のエージェントに各サブタスクを割り当てることです。

マルチエージェント システムでは、各エージェントがタスクを効果的に実行するために特定のコンテキストを必要とします。コンテキストには、ドキュメント、過去の設定、関連リンク、会話履歴、運用上の制約などが含まれます。この情報フローを管理するプロセスは、コンテキスト エンジニアリングと呼ばれます。

マルチエージェント システムの構築には、単一エージェント システムと比較して、評価、セキュリティ、信頼性、費用の面で追加の考慮事項が必要です。

---

### シーケンス パターン

- マルチエージェント シーケンシャル パターンは、事前定義された線形順序で一連の特殊なエージェントを実行します。このパターンでは、あるエージェントの出力が次のエージェントの直接入力として使用されます。
- オペレーションの順序が変わらない、高度に構造化された再現可能なプロセスには、シーケンシャル パターンを使用します。
- シーケンシャル パターンを使用すると、AI モデルを使用してタスク ワークフローをオーケストレートするパターンと比較して、レイテンシと運用コストを削減できます。ただし、この効率性には柔軟性が犠牲になるという代償が伴います。パイプラインの構造が厳密に事前定義されているため、動的な条件に適応したり、不要なステップをスキップしたりすることが難しく、処理の効率が低下したり、不要なステップが遅い場合は累積レイテンシが増加したりする可能性があります。

---

### 並列パターン

- マルチエージェント並列パターン（同時実行パターンとも呼ばれます）では、複数の専門サブエージェントがタスクまたはサブタスクを同時に独立して実行します。サブエージェントの出力が統合され、最終的な統合レスポンスが生成されます。
- 並列パターンでは、複数のソースから同時にさまざまな情報を収集できるため、順次アプローチと比較して全体的なレイテンシを短縮できます。ただし、このアプローチではコストと複雑さのトレードオフが発生します。複数のエージェントを並行して実行すると、リソース使用率とトークン消費量が直ちに増加し、運用費用が増加します。また、収集ステップでは、競合する可能性のある結果を合成するための複雑なロジックが必要になるため、システムの開発とメンテナンスのオーバーヘッドが増加します。

---

### ループ パターン

- マルチエージェント ループ エージェント パターンは、特定の終了条件が満たされるまで、一連の特殊なサブエージェントを繰り返し実行します。
- すべてのサブエージェントがタスクを完了すると、ループ エージェントは終了条件が満たされているかどうかを評価します。
- このパターンの主なトレードオフは、無限ループのリスクです。終了条件が正しく定義されていない場合や、停止に必要な状態をサブエージェントが生成できない場合、ループは無限に実行される可能性があります。これにより、運用コストの増加、リソースの消費量の増加、システムのハングアップが発生する可能性があります。

---

### レビューと批評のパターン

- レビューと批判のパターンでは、生成エージェントがコードブロックやドキュメントの要約などの初期出力を生成します。次に、批評エージェントが、事実の正確性、形式ルールや安全に関するガイドラインの遵守など、事前定義された一連の基準に照らしてこの出力を評価します。評価に基づいて、批評家はコンテンツを承認、拒否、または修正のフィードバックとともにジェネレータに返すことができます。
- レビュー担当者と批評のパターンは、専用の検証ステップを追加するため、出力の品質、精度、信頼性を向上させることができます。ただし、この品質保証には、レイテンシの増加と運用費用の増加という直接的なコストがかかります。

---

### 反復的な改良パターン

- このパターンでは、1 つ以上のエージェントがループ内で動作し、各イテレーション中にセッション状態に保存されている結果を変更します。
- このプロセスは、出力が事前定義された品質しきい値を満たすか、最大反復回数に達するまで継続されます。これにより、無限ループが防止されます。
- このパターンは、1 つのステップで出力を実現することが難しい複雑な生成タスクに適しています。
- このパターンでは、過剰なコストや制御不能な実行を防ぐために、品質評価や最大イテレーション制限などの終了条件を慎重に設計する必要があるため、アーキテクチャの複雑さも増します。

---

### コーディネーター パターン

- マルチエージェント コーディネーター パターンは、中央エージェントであるコーディネーターを使用してワークフローを指示します。コーディネーターは、ユーザーのリクエストを分析してサブタスクに分解し、各サブタスクを実行する専門のエージェントにディスパッチします。各専門エージェントは、データベースのクエリや API の呼び出しなど、特定の機能の専門家です。
- たとえば、カスタマー サービス エージェントがコーディネーターとして機能できます。コーディネーター エージェントは、リクエストを分析して、注文ステータスのリクエスト、商品の返品、払い戻しのリクエストのいずれであるかを判断します。リクエストのタイプに基づいて、コーディネーターはタスクを適切な専門エージェントに転送します。
- コーディネーター パターンは、より厳密な事前定義されたワークフローと比較して柔軟性があります。モデルを使用してタスクをルーティングすることで、コーディネーターはより幅広い入力に対応し、実行時にワークフローを適応させることができます。

---

### 階層型タスク分解パターン

- 最上位の親エージェント（ルートエージェント）は複雑なタスクを受け取り、そのタスクを複数の小さく管理しやすいサブタスクに分解します。ルート エージェントは、各サブタスクを下位レベルの専門サブエージェントに委任します。このプロセスは複数のレイヤで繰り返される可能性があります。エージェントは、割り当てられたタスクを、最下位レベルのワーカー エージェントが直接実行できるほど単純になるまで、段階的に分解します。
- 研究、計画、統合などのタスクなど、複数ステップの推論が必要な曖昧でオープンエンドの問題には、階層型タスク分解パターンを使用します。
- 階層型タスク分解パターンは、非常に複雑で曖昧な問題を解決するのに最適です。なぜなら、管理可能なサブタスクに体系的に分解できるからです。

---

### スワーム パターン

- スウォーム パターンは、ディスパッチャー エージェントを使用して、ユーザー リクエストを専門のエージェントの共同グループに転送します。
- ディスパッチャー エージェントがリクエストを解釈し、タスクの開始に最適なスウォーム内のエージェントを決定します。このパターンでは、各エージェントが他のすべてのエージェントと通信できるため、調査結果の共有、提案の批評、互いの作業の積み重ねによるソリューションの反復的な改善が可能になります。
- スウォーム内のエージェントは、次のステップの処理に適していると判断した別のエージェントにタスクを引き渡すことができます。また、コーディネーター エージェントを介してユーザーに最終レスポンスを伝えることもできます。
- 通常、スワームにはプロセスを追跡する中央のスーパーバイザーまたはコーディネーター エージェントがありません。ディスパッチャ エージェントは、コーディネーター パターンとは異なり、エージェント ワークフローをオーケストレートしません。代わりに、ディスパッチャー エージェントがスウォーム サブエージェントとユーザー間の通信を促進します。
- スワームが最終的に停止して結果を返すようにするには、明示的な終了条件を定義する必要があります。この条件は、多くの場合、最大イテレーション回数、時間制限、コンセンサスの達成などの特定の目標の達成です。
- 議論や反復的な改善が有効な、曖昧な問題や非常に複雑な問題には、スウォーム パターンを使用します。専門家チームのコラボレーションをシミュレートするため、非常に高品質で創造的なソリューションを生み出すことができます。

---

### 推論と行動（ReAct）パターン

- ReAct パターンは、AI モデルを使用して思考プロセスとアクションを自然言語のインタラクションのシーケンスとしてフレーム化するアプローチです。このパターンでは、終了条件が満たされるまで、エージェントは思考、行動、観察の反復ループで動作します。
  - **思考**: モデルはタスクについて推論し、次のアクションを決定します。モデルは収集したすべての情報を評価し、ユーザーのリクエストに完全に回答できたかどうかを判断します。
  - **アクション**: モデルは思考プロセスに基づいて、次のいずれかのアクションを実行します。
    - タスクが完了していない場合は、ツールを選択し、より多くの情報を収集するためのクエリを作成します。
    - タスクが完了すると、ユーザーに送信する最終的な回答が作成され、ループが終了します。
  - **観測**: モデルはツールから出力を受け取り、関連情報をメモリに保存します。モデルは関連する出力を保存するため、以前の観測に基づいて構築できます。これにより、モデルが同じことを繰り返したり、コンテキストを失ったりすることを防ぐことができます。
- 継続的な計画と適応が必要な複雑で動的なタスクには、ReAct パターンを使用します。
- 単一の ReAct エージェントは、複雑なマルチエージェント システムよりも実装とメンテナンスが簡単で、費用対効果も高くなります。モデルの思考では、モデルの推論の文字起こしが提供されるため、デバッグに役立ちます。
- ただし、この柔軟性にはトレードオフがあります。ループの反復的なマルチステップの性質により、単一のクエリよりもエンドツーエンドのレイテンシが高くなる可能性があります。また、エージェントの有効性は、AI モデルの推論の品質に大きく依存します。そのため、1 つの観測ステップでツールからエラーや誤解を招く結果が返されると、それが伝播して最終的な回答が誤ったものになる可能性があります。

---

### 人間参加型パターン

- 人間参加型パターンでは、人間による介入のポイントがエージェントのワークフローに直接統合されます。エージェントは、事前に定義されたチェックポイントで実行を一時停止し、外部システムを呼び出して、人間が作業をレビューするのを待ちます。このパターンを使用すると、エージェントが続行する前に、ユーザーが決定を承認したり、エラーを修正したり、必要な入力を提供したりできます。
- 人間による監視、主観的な判断、重要なアクションの最終承認が必要なタスクには、人間参加型のパターンを使用します。
- 人間参加型パターンは、ワークフロー内の重要な意思決定ポイントに人間の判断を挿入することで、安全性と信頼性を向上させます。このパターンでは、ユーザー インタラクション用の外部システムを構築して維持する必要があるため、アーキテクチャの複雑性が大幅に増す可能性があります。

---

### カスタム ロジック パターン

- 他のパターンが提供する構造化されたアプローチを超える、ロジックレベルのオーケストレーションに独自のソリューションが必要なとき
- エージェントの実行をきめ細かく制御する必要がある場合や、ワークフローがこのドキュメントで説明されている他のパターンのいずれにも適合しない場合は、カスタム ロジック パターンを使用します。
- ただし、このアプローチでは開発とメンテナンスの複雑さが増します。オーケストレーション フロー全体を設計、実装、デバッグする必要があります。これには、Agent Development Kit（ADK）などのツールでサポートされている事前定義パターンを使用するよりも、多くの開発作業が必要になり、エラーが発生しやすくなります。

---

## 設計パターンを比較する

### 確定的ワークフロー

決定論的ワークフローには、予測可能で順次実行されるタスクが含まれ、開始から終了までのワークフロー パスが明確に定義されています。タスクのステップは事前にわかっており、プロセスは実行ごとに大きく変わりません。

- **順次パターン**
  - 事前定義された厳格なワークフローに沿ったマルチステップ タスク
  - モデル オーケストレーションは不要
  - オペレーションの順序が固定されている。1 つのエージェントの出力は、シーケンス内の次のエージェントの直接入力になる
- **並列パターン**
  - 同時に実行できる独立したタスク
  - モデル オーケストレーションは不要
  - サブタスクを同時に実行することで、全体的なレイテンシを短縮する
- **反復的な改良パターン**
  - 1 回の試行で完了することが難しい、オープンエンドまたは複雑な生成タスク
  - エージェントが複数のサイクルにわたって出力を段階的に改善する必要がある
  - モデル オーケストレーションは不要
  - レイテンシよりも出力品質を優先する

### 動的オーケストレーションを必要とするワークフロー

動的オーケストレーションが必要なワークフローには、エージェントが最適な手順を判断する必要がある複雑な問題が含まれます。エージェント AI システムは、事前定義されたスクリプトなしでタスクを動的に計画、委任、調整する必要があります。

- **単一エージェントパターン**
  - 外部ツールの使用が必要な構造化されたマルチステップ タスク
  - 概念実証としてソリューションのプロトタイプを迅速に開発する必要がある
- **コーディネーターパターン**
  - さまざまな入力を含む構造化されたタスクに対して、適切な専門サブエージェントへの動的ルーティングが必要
  - コーディネーター AI モデルへの複数の呼び出しにより、タスクを適切なサブエージェントに転送できるため、レイテンシが高くなる
  - コーディネーター エージェントへの呼び出しが複数回行われるため、コストが高くなる可能性がある
- **階層型タスク分解パターン**
  - 複雑でオープンエンドな曖昧なタスクには、マルチレベル モデルのオーケストレーションが必要
  - 曖昧さを分解することが主な課題となる、包括的で高品質な結果が必要
  - ネストされたマルチレベルの分解によりレイテンシが高くなり、推論のために AI モデルが複数回呼び出される
- **スウォームパターン**
  - 非常に複雑で、オープンエンドまたは曖昧なタスクの場合、複数の専門エージェントによる共同での議論と反復的な改善が必要になる
  - 複数の視点を統合して、包括的または創造的な解決策を作成することを優先
  - エージェント間の動的な全対全通信によるレイテンシと運用コストの増加

### 反復処理を含むワークフロー

反復処理を伴うワークフローには、最終的な出力が改善、フィードバック、改善のサイクルを通じて達成されるタスクが含まれます。

- **ReActパターン**
  - 複雑でオープンエンドな動的タスクの計画を構築または適応させるために、エージェントが反復的に推論、行動、観察を行う必要がある
  - レイテンシよりも正確で徹底的な結果を優先
- **ループパターン**
  - エージェントが終了条件を満たすまで、自動チェックなどの事前定義されたアクションを繰り返すモニタリング タスクまたはポーリング タスクが必要
  - 終了条件が満たされるのを待っている間に、予測不能なレイテンシや長時間実行されるレイテンシが発生する
- **レビューと批評のパターン**
  - タスクを完了するには、個別の検証ステップが必要
- **反復的な改良パターン**
  - 1 回の試行で完了することが難しい、オープンエンドまたは複雑な生成タスク
  - エージェントが複数のサイクルにわたって出力を段階的に改善する必要がある
  - モデル オーケストレーションは不要
  - レイテンシよりも出力品質を優先

### 特別な要件があるワークフロー

特別な要件があるワークフローには、一般的なエージェント パターンに従わないタスクが含まれます。タスクには独自のビジネス ロジックを含めることも、重要なポイントで人間の判断と介入が必要になることもあります。エージェント AI システムは、単一の特定の目的のために設計されたカスタムビルドのマシンです。

- **人間参加型パターン**
  - 安全性、信頼性、コンプライアンスの要件を含む可能性のある、重大なタスクや主観的なタスクのため、人間による監督が必要
- **カスタムロジックパターン**
  - 直接的な線形シーケンスを超える複雑な分岐ロジック
  - 事前定義ルールとモデルの推論を組み合わせるために、最大限の制御が必要
  - 標準テンプレートに適合しないワークフローのきめ細かいプロセス制御が必要
