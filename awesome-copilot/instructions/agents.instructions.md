---
description: "GitHub Copilot のカスタムエージェントファイルを作成するためのガイドライン"
applyTo: "**/*.agent.md"
---

# カスタムエージェントファイルのガイドライン

GitHub Copilot の特定の開発タスクに関する専門知識を提供する、効果的で保守可能なカスタム エージェント ファイルを作成する手順。

## プロジェクトの背景

- 対象者: GitHub Copilot 用のカスタムエージェントを作成する開発者
- ファイル形式: YAML フロントマター付き Markdown
- ファイル名の命名規則: 小文字とハイフン (例: `test-specialist.agent.md`)
- 場所: `.github/agents/` ディレクトリ (リポジトリ レベル) または `agents/` ディレクトリ (組織/エンタープライズ レベル)
- 目的: 特定のタスクに合わせた専門知識、ツール、指示を備えた専門エージェントを定義する
- 公式ドキュメント: https://docs.github.com/en/copilot/how-tos/use-copilot-agents/coding-agent/create-custom-agents

## 必須の前文

すべてのエージェントファイルには、次のフィールドを含むYAMLフロントマターを含める必要があります。:

```yaml
---
description: "エージェントの目的と機能の簡単な説明"
name: "Agent Display Name"
tools: ["read", "edit", "search"]
model: "Claude Sonnet 4.5"
target: "vscode"
infer: true
---
```

### コアフロントマタープロパティ

#### **description** (必須)

- エージェントの目的とドメインの専門知識を明確に示す一重引用符で囲まれた文字列
- 簡潔（50～150文字）で実用的な内容であること
- 例: 「テストの範囲、品質、テストのベストプラクティスに焦点を当てます」

#### **name** (オプション)

- UI でのエージェントの表示名
- 省略された場合は、デフォルトでファイル名（`.md` または `.agent.md` なし）になります。
- タイトルを大文字にして説明的にする
- 例: `'Testing Specialist'`

#### **tools** (オプション)

- エージェントが使用できるツール名またはエイリアスのリスト
- カンマ区切りの文字列またはYAML配列形式をサポート
- 省略した場合、エージェントは利用可能なすべてのツールにアクセスできます
- 詳細については、以下の「ツール設定」セクションを参照してください。

#### **model** (STRONGLY RECOMMENDED)

- エージェントが使用するAIモデルを指定します
- VS Code、JetBrains IDE、Eclipse、Xcode でサポートされています
- 例: `'Claude Sonnet 4.5'`, `'gpt-4'`, `'gpt-4o'`
- エージェントの複雑さと必要な機能に基づいて選択する

#### **target** (オプション)

- ターゲット環境を指定します: `'vscode'` または `'github-copilot'`
- 省略した場合、エージェントは両方の環境で使用可能です
- エージェントに環境固有の機能がある場合に使用します

#### **infer** (オプション)

- Copilot がコンテキストに基づいてこのエージェントを自動的に使用できるかどうかを制御するブール値
- デフォルト: 省略した場合は `true`
- エージェントを手動で選択する必要がある場合は `false` に設定します

#### **metadata** (オプション, GitHub.comのみ)

- エージェント注釈の名前と値のペアを持つオブジェクト
- 例: `metadata: { category: 'testing', version: '1.0' }`
- VS Codeではサポートされていません

#### **mcp-servers** (オプション, Organization/Enterpriseのみ)

- このエージェントのみが利用できるMCPサーバーを構成する
- 組織/エンタープライズレベルのエージェントのみサポートされます
- 下記の「MCPサーバーの構成」セクションを参照してください。

#### **handoffs** (オプション, VS Codeのみ)

- エージェント間の遷移と次のステップの提案を行うガイド付きシーケンシャルワークフローを有効にする
- ハンドオフ設定のリスト（それぞれターゲットエージェントとオプションのプロンプトを指定）
- チャットの応答が完了すると、ハンドオフボタンが表示され、ユーザーは次のエージェントに移動できます。
- VS Code（バージョン 1.106 以降）でのみサポートされます
- 詳細については、以下の「ハンドオフ設定」セクションを参照してください。

## ハンドオフ設定

ハンドオフを使用すると、カスタムエージェント間をシームレスに遷移するガイド付きのシーケンシャルワークフローを作成できます。これは、ユーザーが次のステップに進む前に各ステップをレビューして承認できる、複数ステップの開発ワークフローをオーケストレーションするのに役立ちます。

### 一般的なハンドオフパターン

- **計画 → 実行**: 計画エージェントで計画を生成し、実装エージェントに渡してコーディングを開始します。
- **実装 → レビュー**: 実装を完了したら、コードレビューエージェントに切り替えて品質とセキュリティの問題をチェックします。
- **失敗するテストを書く → 成功するテストを書く**: 失敗するテストを生成し、それらのテストをパスさせるコードを実装するために引き渡す
- **研究 → 文書化**: トピックを調査し、その後、ガイドを作成するためにドキュメンテーションエージェントに移行します

### ハンドオフ前文構造

エージェントファイルのYAMLフロントマターで「handoffs」フィールドを使用してハンドオフを定義します:

```yaml
---
description: "エージェントの簡単な説明"
name: "Agent Name"
tools: ["search", "read"]
handoffs:
  - label: 実装を開始する
    agent: implementation
    prompt: "次に、上記で概説した計画を実行します。"
    send: false
  - label: コードレビュー
    agent: code-review
    prompt: "品質とセキュリティの問題がないか実装を確認してください。"
    send: false
---
```

### ハンドオフプロパティ

リスト内の各ハンドオフには次のプロパティが含まれている必要があります:

| プロパティ | タイプ  | 必須 | 説明                                                                                        |
| ---------- | ------- | ---- | ------------------------------------------------------------------------------------------- |
| `label`    | string  | Yes  | チャットインターフェースのハンドオフボタンに表示される表示テキスト                          |
| `agent`    | string  | Yes  | 切り替え先のターゲットエージェント識別子（名前または`.agent.md` のないファイル名）          |
| `prompt`   | string  | No   | 対象エージェントのチャット入力に事前入力するプロンプトテキスト                              |
| `send`     | boolean | No   | `true` の場合、プロンプトをターゲットエージェントに自動的に送信します (デフォルト: `false`) |

### ハンドオフ動作

- **ボタン表示**: チャットの応答が完了すると、対話型の提案としてハンドオフ ボタンが表示されます。
- **コンテキストの保存**: ユーザーがハンドオフボタンを選択すると、会話のコンテキストを維持したままターゲットエージェントに切り替わります。
- **事前入力されたプロンプト**: `prompt` が指定されている場合は、ターゲットエージェントのチャット入力に事前に入力されて表示されます。
- **手動 vs 自動**: `send: false` の場合、ユーザーは事前に入力されたプロンプトを確認して手動で送信する必要があります。`send: true` の場合、プロンプトは自動的に送信されます。

### ハンドオフ構成ガイドライン

#### ハンドオフを使用するタイミング

- **複数ステップのワークフロー**: 複雑なタスクを専門のエージェントに分割する
- **品質ゲート**: 実装フェーズ間のレビュー手順の確保
- **ガイド付きプロセス**: 構造化された開発プロセスを通じてユーザーを誘導する
- **スキルの移行**: 計画・設計から実装・テストの専門家へ

#### ベストプラクティス

- **クリアラベル**: 次のステップを明確に示すアクション指向のラベルを使用する
  - ✅ Good: 「実装の開始」、「セキュリティのレビュー」、「テストの作成」
  - ❌ Avoid: "Next", 「エージェントに行く」、「何かする」

- **関連するプロンプト**: 完了した作業を参照するコンテキスト認識プロンプトを提供する
  - ✅ Good: `'次に、上記で概説した計画を実行します。'`
  - ❌ Avoid: 文脈のない一般的なプロンプト

- **選択的使用**: あらゆるエージェントに引き継ぎを作成せず、論理的なワークフローの遷移に焦点を当てます
  - エージェントごとに最も関連性の高い次のステップを 2～3 つに制限します
  - ワークフローに自然に従うエージェントにのみハンドオフを追加します

- **エージェントの依存関係**: ハンドオフを作成する前にターゲットエージェントが存在することを確認する
  - 存在しないエージェントへのハンドオフは無視されます
  - ハンドオフをテストして期待通りに動作するか確認する

- **プロンプト内容**: プロンプトは簡潔かつ実行可能なものにする
  - コンテンツを重複させずに現在のエージェントの作業を参照する
  - 対象エージェントが必要とする可能性のあるコンテキストを提供する

### 例: 完成したワークフロー

3人のエージェントがハンドオフを行い、完全なワークフローを作成する例を示します:

**計画エージェント** (`planner.agent.md`):

```yaml
---
description: '新機能やリファクタリングの実装計画を作成する'
name: 'Planner'
tools: ['search', 'read']
handoffs:
  - label: 計画を実行する
    agent: implementer
    prompt: '上記の計画を実行します。'
    send: false
---
# 計画エージェント
あなたはプランニングスペシャリストです。あなたの仕事は:
1. 要件を分析する
2. 作業を論理的なステップに分解する
3. 詳細な実装計画を作成する
4. テスト要件を特定する

コードを書かずに、計画だけに集中してください。
```

**実装エージェント** (`implementer.agent.md`):

```yaml
---
description: '計画や仕様に基づいてコードを実装する'
name: 'Implementer'
tools: ['read', 'edit', 'search', 'execute']
handoffs:
  - label: 実装のレビュー
    agent: reviewer
    prompt: 'コードの品質、セキュリティ、ベスト プラクティスの遵守については、この実装を確認してください。'
    send: false
---
# 実装エージェント
あなたは実装スペシャリストです。あなたの仕事は:
1. 提供された計画または仕様に従う
2. クリーンで保守しやすいコードを書く
3. 適切なコメントとドキュメントを含める
4. プロジェクトのコーディング標準に従う

ソリューションを完全に徹底的に実装します。
```

**レビューエージェント** (`reviewer.agent.md`):

```yaml
---
description: '品質、セキュリティ、ベストプラクティスについてコードをレビューする'
name: 'Reviewer'
tools: ['read', 'search']
handoffs:
  - label: 計画に戻る
    agent: planner
    prompt: '上記のフィードバックを確認し、新しい計画が必要かどうかを判断します。'
    send: false
---
# コードレビューエージェント
あなたはコードレビューの専門家です。あなたの仕事は:
1. コードの品質と保守性をチェックする
2. セキュリティ上の問題と脆弱性を特定する
3. プロジェクト標準の遵守を確認する
4. 改善を提案する

実装に関する建設的なフィードバックを提供します。
```

このワークフローにより、開発者は:

1. プランナーエージェントを使って詳細な計画を作成しましょう
2. 計画に基づいてコードを書くために実装エージェントに引き渡す
3. 実装を確認するためにレビュー担当者に引き継ぎます
4. 重大な問題が見つかった場合は、必要に応じて計画に引き継ぐ

### バージョンの互換性

- **VS Code**: ハンドオフはVS Code 1.106以降でサポートされています
- **GitHub.com**: 現在サポートされていません。エージェント移行ワークフローでは異なるメカニズムが使用されます
- **Other IDEs**: サポートは限定的または全くなく、最大限の互換性のために VS Code 実装に重点を置いています

## ツール構成

### ツール仕様戦略

**すべてのツールを有効にする** (default):

```yaml
# toolsプロパティを完全に省略するか、下記の記述をする:
tools: ["*"]
```

**特定のツールを有効にする**:

```yaml
tools: ["read", "edit", "search", "execute"]
```

**MCPサーバーツールを有効にする**:

```yaml
tools: ["read", "edit", "github/*", "playwright/navigate"]
```

**すべてのツールを無効にする**:

```yaml
tools: []
```

### 標準ツールエイリアス

すべてのエイリアスは大文字と小文字を区別しません:

| エイリアス | 別名                                 | カテゴリ         | 説明                                         |
| ---------- | ------------------------------------ | ---------------- | -------------------------------------------- |
| `execute`  | shell, Bash, powershell              | Shell execution  | 適切なシェルでコマンドを実行する             |
| `read`     | Read, NotebookRead, view             | File reading     | ファイルの内容を読み取る                     |
| `edit`     | Edit, MultiEdit, Write, NotebookEdit | File editing     | ファイルの編集と変更                         |
| `search`   | Grep, Glob, search                   | Code search      | ファイルまたはファイル内のテキストを検索する |
| `agent`    | custom-agent, Task                   | Agent invocation | 他のカスタムエージェントを呼び出す           |
| `web`      | WebSearch, WebFetch                  | Web access       | ウェブコンテンツを取得して検索する           |
| `todo`     | TodoWrite                            | Task management  | タスク リストの作成と管理 (VS Code のみ)     |

### 組み込みのMCPサーバーツール

**GitHub MCP Server**:

```yaml
tools: ['github/*']  # すべてのGitHubツール
tools: ['github/get_file_contents', 'github/search_repositories']  # 特定のツール
```

- すべての読み取り専用ツールはデフォルトで使用可能
- ソースリポジトリにスコープされたトークン

**Playwright MCP Server**:

```yaml
tools: ['playwright/*']  # すべてのPlaywrightツール
tools: ['playwright/navigate', 'playwright/screenshot']  # 特定のツール
```

- ローカルホストのみにアクセスするように設定
- ブラウザの自動化とテストに役立ちます

### ツール選択のベストプラクティス

- **最小権限の原則**: エージェントの目的に必要なツールのみを有効にする
- **セキュリティ**: 明示的に要求されない限り、`execute` アクセスを制限する
- **集中**: ツールが少ない = エージェントの目的が明確になり、パフォーマンスが向上する
- **ドキュメント化**: 複雑な構成に特定のツールが必要な理由をコメントしてください

## サブエージェントの呼び出し（エージェントオーケストレーション）

エージェントは、**エージェント呼び出しツール** (`エージェント` ツール) を使用して他のエージェントを呼び出し、複数ステップのワークフローを調整できます。

推奨されるアプローチは**プロンプトベースのオーケストレーション**です:

- オーケストレーターは、自然言語でステップバイステップのワークフローを定義します。
- 各ステップは専門のエージェントに委任されます。
- オーケストレーターは、必須のコンテキスト (基本パス、識別子など) のみを渡し、各サブエージェントにツール/制約の独自の `.agent.md` 仕様を読み取ることを要求します。

### 仕組み

1. オーケストレーターのツールリストに `agent` を含めることでエージェントの呼び出しを有効にします:

```yaml
tools: ["read", "edit", "search", "agent"]
```

2. 各ステップで、以下を指定してサブエージェントを起動します。:

- **エージェント名** （ユーザーが選択/呼び出す識別子）
- **エージェント仕様パス** （読んで従うべき `.agent.md` ファイル）
- **最小限の共有コンテキスト** （例: `basePath`、`projectName`、`logFile`）

### プロンプトパターン（推奨）

サブエージェントが予測通りに動作するように、すべてのステップで一貫した「ラッパープロンプト」を使用します:

```text
このフェーズは、「<AGENT_SPEC_PATH>」で定義されたエージェント「<AGENT_NAME>」として実行する必要があります。

重要:
- .agent.md 仕様全体 (ツール、制約、品質基準) を読んで適用します。
- ベース パスが「<BASE_PATH>」である「<WORK_UNIT_NAME>」で作業します。
- この基本パスの下で必要な読み取り/書き込みを実行します。
- 明確な概要を返します (実行されたアクション + 作成/変更されたファイル + 問題)。
```

オプション: 追跡可能性のために軽量で構造化されたラッパーが必要な場合は、プロンプトに小さな JSON ブロックを埋め込みます (人間が読めるツールに依存しないまま):

```text
{
  "step": "<STEP_ID>",
  "agent": "<AGENT_NAME>",
  "spec": "<AGENT_SPEC_PATH>",
  "basePath": "<BASE_PATH>"
}
```

### オーケストレーターの構造（汎用性を保つ）

保守可能なオーケストレーターのために、これらの構造要素を文書化する:

- **動的パラメータ**: ユーザーから抽出される値 （例: `projectName`、`fileName`、`basePath`）。
- **サブエージェントレジストリ**: 各ステップを `agentName` + `agentSpecPath` にマッピングするリスト/テーブル。
- **ステップの順序**: 明示的なシーケンス（ステップ 1 → ステップ N）。
- **トリガー条件** （オプションですが推奨）: ステップが実行されるタイミングとスキップされるタイミングを定義します。
- **ログ戦略** （オプションですが推奨）: 各ステップの後に更新される単一のログ/レポート ファイル。

オーケストレータープロンプト内にオーケストレーション「コード」（JavaScript、Python など）を埋め込むことは避け、決定論的なツール駆動型の調整を優先します。

### 基本パターン

各ステップの呼び出しを構成する:

1. **ステップの説明**: 明確な一行の目的（ログとトレーサビリティに使用）
2. **エージェントID**: `agentName` + `agentSpecPath`
3. **コンテクスト**: 小さな明示的な変数セット（パス、ID、環境名）
4. **期待される出力**: 作成/更新するファイルとその書き込み先
5. **返却概要**: サブエージェントに短く構造化された要約を返すように依頼する

### 例: マルチステップ処理

```text
Step 1: 生の入力データを変換する
Agent: data-processor
Spec: .github/agents/data-processor.agent.md
Context: projectName=${projectName}, basePath=${basePath}
Input: ${basePath}/raw/
Output: ${basePath}/processed/
Expected: `${basePath}/processed/summary.md`に書き込む

Step 2: 処理されたデータを分析する（ステップ1の出力に依存）
Agent: data-analyst
Spec: .github/agents/data-analyst.agent.md
Context: projectName=${projectName}, basePath=${basePath}
Input: ${basePath}/processed/
Output: ${basePath}/analysis/
Expected: `${basePath}/analysis/report.md`に書き込む
```

### 要点

- **プロンプトで変数を渡す**: すべての動的な値には `${variableName}` を使用します
- **プロンプトを集中させる**: 各サブエージェントの明確で具体的なタスク
- **返却概要**: 各サブエージェントは達成したことを報告する必要がある
- **順次実行**: 出力と入力の間に依存関係がある場合にステップを順番に実行する
- **エラー処理**: 依存する手順に進む前に結果を確認する

### ⚠️ ツールの可用性要件

**クリティカル**: サブエージェントが特定のツール（例：`edit`、`execute`、`search`）を必要とする場合、オーケストレーターはそれらのツールを自身の`tools`リストに含める必要があります。サブエージェントは、親オーケストレーターが利用できないツールにアクセスできません。

**例**:

```yaml
# サブエージェントがファイルを編集したり、コマンドを実行したり、コードを検索したりする必要がある場合
tools: ["read", "edit", "search", "execute", "agent"]
```

オーケストレーターのツール権限は、呼び出されるすべてのサブエージェントの上限として機能します。すべてのサブエージェントに必要なツールが確実に提供されるよう、ツールリストを慎重に計画してください。

### ⚠️ 重要な制限事項

**サブエージェント オーケストレーションは、大規模なデータ処理には適していません。** マルチステップサブエージェントパイプラインの使用を避ける:

- 数百または数千のファイルの処理
- 大規模データセットの取り扱い
- 大規模なコードベースでの一括変換の実行
- 5～10以上の連続ステップのオーケストレーション

サブエージェントの呼び出しごとにレイテンシとコンテキストのオーバーヘッドが増加します。大量の処理が必要な場合は、単一のエージェントに直接ロジックを実装してください。オーケストレーションは、集中管理可能なデータセットにおける特殊なタスクの調整にのみ使用してください。

## エージェントプロンプトの構造

フロントマターの下のマークダウンコンテンツは、エージェントの行動、専門知識、指示を定義します。適切に構成されたプロンプトには通常、次のような内容が含まれます。:

1. **エージェントのアイデンティティと役割**: エージェントとは誰であり、その主な役割は何か
2. **主な責任**: エージェントが実行する具体的なタスク
3. **アプローチと方法論**: エージェントがタスクを達成する仕組み
4. **ガイドラインと制約**: 何をすべきか/避けるべきか、そして品質基準
5. **出力の期待値**: 期待される出力形式と品質

### プロンプトライティングのベストプラクティス

- **具体的かつ直接的に**: 命令形（「分析する」「生成する」）を使用する；曖昧な表現は避ける
- **境界を定義する**: 範囲の制限と制約を明確に示す
- **コンテキストを含める**: ドメインの専門知識を説明し、関連するフレームワークを参照する
- **行動に焦点を当てる**: エージェントがどのように考え、行動すべきかを説明する
- **構造化フォーマットを使用する**: ヘッダー、箇条書き、リストによりプロンプトが読みやすくなります

## 変数の定義と抽出

エージェントは動的なパラメータを定義してユーザー入力から値を抽出し、エージェント自身の動作やサブエージェント間の通信で使用することができます。これにより、ユーザーが提供するデータに適応する、柔軟でコンテキストを認識するエージェントが実現します。

### 変数を使用する場合

**変数を使用するのは**:

- エージェントの動作はユーザーの入力に依存する
- サブエージェントに動的な値を渡す必要がある
- エージェントをさまざまなコンテキストで再利用できるようにしたい
- パラメータ化されたワークフローを必要とする
- ユーザーが提供するコンテキストを追跡または参照する必要がある

**例**:

- ユーザープロンプトからプロジェクト名を抽出する
- パイプライン処理の認証名を取得する
- ファイルパスまたはディレクトリを識別する
- 設定オプションを抽出する
- 機能名またはモジュール識別子を解析する

### 変数宣言パターン

エージェントプロンプトの早い段階で変数セクションを定義して、予想されるパラメータを文書化します:

```markdown
# エージェント名

## 動的パラメータ

- **パラメータ名**: 説明と使用方法
- **別のパラメータ**: 抽出方法と使用方法

## あなたの使命

[task] を完了するには [PARAMETER_NAME] を処理します。
```

### 変数抽出法

#### 1. **明示的なユーザー入力**

プロンプトで変数が検出されない場合は、ユーザーに変数を提供するよう求めます:

```markdown
## あなたの使命

コードベースを分析してプロジェクトを処理します。

### Step 1: プロジェクトの特定

プロジェクト名が指定されていない場合は、**ユーザーに問い合わせてください**:

- プロジェクト名または識別子
- ベースパスまたはディレクトリの場所
- 構成タイプ（該当する場合）

この情報を使用して、後続のすべてのタスクのコンテキストを設定します。
```

#### 2. **プロンプトからの暗黙的な抽出**

ユーザーの自然言語入力から変数を自動的に抽出する:

```javascript
// 例: ユーザー入力から認証名を抽出する
const userInput = "Process My Certification";

// 重要な情報を抽出する
const certificationName = extractCertificationName(userInput);
// 結果: "My Certification"

const basePath = `certifications/${certificationName}`;
// 結果: "certifications/My Certification"
```

#### 3. **コンテキスト変数の解決**

ファイルコンテキストまたはワークスペース情報を使用して変数を導出する:

```markdown
## 可変解像度戦略

1. **ユーザープロンプトから**: まず、ユーザー入力で明示的な言及を探す
2. **ファイルコンテキストから**: 現在のファイル名またはパスを確認する
3. **ワークスペースから**: ワークスペースフォルダまたはアクティブなプロジェクトを使用する
4. **設定から**: 参照設定ファイル
5. **ユーザーに質問する**: それでもダメなら、不足している情報をリクエストする
```

### エージェントプロンプトでの変数の使用

#### 命令における変数の置換

エージェントプロンプトでテンプレート変数を使用して動的にする:

```markdown
# エージェント名

## 動的パラメータ

- **プロジェクト名**: ${projectName}
- **ベースパス**: ${basePath}
- **出力ディレクトリ**: ${outputDir}

## あなたの使命

`${basePath}` にある **${projectName}** プロジェクトを処理します。

## プロセスステップ

1. `${basePath}/input/`から入力を読み込む
2. プロジェクト構成に従ってファイルを処理する
3. `${outputDir}/`へ結果を書き込む
4. 概要レポートを生成する

## 品質基準

- **${projectName}** のプロジェクト固有のコーディング標準を維持する
- `${basePath}/[structure]`のディレクトリ構造に従う
```

#### サブエージェントへの変数の受け渡し

サブエージェントを呼び出す際は、プロンプト内の置換変数を通してすべてのコンテキストを渡します。ファイルの内容全体ではなく、**パスと識別子**を渡すことをお勧めします。

例（プロンプトテンプレート）:

```text
このフェーズは、「.github/agents/documentation-writer.agent.md」で定義されているエージェント「documentation-writer」として実行する必要があります。

重要:
- .agent.md 仕様全体を読んで適用します。
- プロジェクト: "${projectName}"
- ベースパス: "projects/${projectName}"
- 入力: "projects/${projectName}/src/"
- 出力: "projects/${projectName}/docs/"

タスク:
1. 入力パスの下のソース ファイルを読み取ります。
2. ドキュメントを生成します。
3. 出力パスの下に出力を書き込みます。
4. 簡潔な概要（作成/更新されたファイル、主要な決定、問題）を返します。
```

サブエージェントは、プロンプトに埋め込まれた必要なコンテキストをすべて受け取ります。変数はプロンプトを送信する前に解決されるため、サブエージェントは変数プレースホルダーではなく、具体的なパスと値で動作します。

### 実例: コードレビューオーケストレーター

複数の専門エージェントを通じてコードを検証するシンプルなオーケストレーターの例:

1. 共通のコンテキストを決定する:

- `repositoryName`, `prNumber`
- `basePath`（例：`projects/${repositoryName}/pr-${prNumber}`）

2. 特殊エージェントを順番に呼び出します（各エージェントは独自の `.agent.md` 仕様を読み取ります）:

```text
Step 1: セキュリティレビュー
Agent: security-reviewer
Spec: .github/agents/security-reviewer.agent.md
Context: repositoryName=${repositoryName}, prNumber=${prNumber}, basePath=projects/${repositoryName}/pr-${prNumber}
Output: projects/${repositoryName}/pr-${prNumber}/security-review.md

Step 2: テスト範囲
Agent: test-coverage
Spec: .github/agents/test-coverage.agent.md
Context: repositoryName=${repositoryName}, prNumber=${prNumber}, basePath=projects/${repositoryName}/pr-${prNumber}
Output: projects/${repositoryName}/pr-${prNumber}/coverage-report.md

Step 3: 集計
Agent: review-aggregator
Spec: .github/agents/review-aggregator.agent.md
Context: repositoryName=${repositoryName}, prNumber=${prNumber}, basePath=projects/${repositoryName}/pr-${prNumber}
Output: projects/${repositoryName}/pr-${prNumber}/final-review.md
```

#### 例: 条件付きステップオーケストレーション（コードレビュー）

この例では、**事前チェック**、**条件付きステップ**、**必須とオプション**の動作を含む、より完全なオーケストレーションを示します。

**動的パラメータ（入力）:**

- `repositoryName`, `prNumber`
- `basePath`（例：`projects/${repositoryName}/pr-${prNumber}`）
- `logFile`（例：`${basePath}/.review-log.md`）

**事前チェック（推奨）:**

- 必要なフォルダ/ファイルが存在することを確認する。（例：`${basePath}/changes/`, `${basePath}/reports/`）
- ステップ トリガーに影響する高レベルの特性（リポジトリ言語、`package.json`、`pom.xml`、`requirements.txt`、テスト フォルダーの存在など）を検出します。
- 開始時に調査結果を一度記録します。

**ステップトリガー条件:**

| ステップ                    | ステータス | トリガー条件                                                                         | 失敗した場合       |
| --------------------------- | ---------- | ------------------------------------------------------------------------------------ | ------------------ |
| 1: セキュリティレビュー     | **必須**   | 常に実行する                                                                         | パイプラインを停止 |
| 2: 依存関係監査             | オプション | 依存関係マニフェストが存在する場合（`package.json`、`pom.xml` など）                 | 続ける             |
| 3: テストカバレッジチェック | オプション | テストプロジェクト/ファイルが存在する場合                                            | 続ける             |
| 4: パフォーマンスチェック   | オプション | パフォーマンスに敏感なコードが変更された場合、またはパフォーマンス設定が存在する場合 | 続ける             |
| 5: 集計と評決               | **必須**   | ステップ1が完了したら常に実行                                                        | パイプラインを停止 |

**実行フロー（自然言語）:**

1. `basePath` を初期化し、`logFile` を作成/更新します。
2. 事前チェックを実行し、記録します。
3. ステップ1→Nを順に実行します。
4. 各ステップごとに:

- トリガー条件が偽の場合: **SKIPPED** としてマークし、続行します。
- それ以外の場合: ラッパープロンプトを使用してサブエージェントを呼び出し、その概要を取得します。
- **成功** または **失敗** としてマークします。
- ステップが **必須** であり失敗した場合: パイプラインを停止し、失敗の概要を書き込みます。

5. 最終要約セクション（全体的なステータス、成果物、次のアクション）で終了します。

**サブエージェント呼び出しプロンプト（例）:**

```text
このフェーズは、「.github/agents/security-reviewer.agent.md」で定義されているエージェント「security-reviewer」として実行する必要があります。

重要:
- .agent.md 仕様全体を読んで適用します。
- リポジトリ「${repositoryName}」の PR「${prNumber}」で作業します。
- ベースパス: "${basePath}"

タスク:
1. 「${basePath}/changes/」の下の変更を確認します。
2. 調査結果を「${basePath}/reports/security-review.md」に書き込みます。
3. 重要な発見、推奨される修正、作成/変更されたファイルを含む短い概要を返します。
```

**ログ形式（例）:**

```markdown
## Step 2: 依存関係監査

**Status:** ✅ SUCCESS / ⚠️ SKIPPED / ❌ FAILED
**Trigger:** package.json present
**Started:** 2026-01-16T10:30:15Z
**Completed:** 2026-01-16T10:31:05Z
**Duration:** 00:00:50
**Artifacts:** reports/dependency-audit.md
**Summary:** [エージェントの簡単な概要]
```

このパターンは、変数を抽出し、明確なコンテキストでサブエージェントを呼び出し、結果を待機するなど、あらゆるオーケストレーション シナリオに適用されます。

### 変数のベストプラクティス

#### 1. **明確なドキュメント**

どのような変数が予想されるかを常に文書化する:

```markdown
## 必須変数

- **projectName**: プロジェクト名（文字列、必須）
- **basePath**: プロジェクト ファイルのルート ディレクトリ（パス、必須）

## オプション変数

- **mode**: 処理モード - クイック/標準/詳細（列挙型、デフォルト: 標準）
- **outputFormat**: 出力形式 - markdown/json/html（列挙型、デフォルト: markdown）

## 派生変数

- **outputDir**: 自動的に${basePath}/outputに設定されます
- **logFile**: 自動的に ${basePath}/.log.md に設定されます
```

#### 2. **一貫した命名**

一貫した変数命名規則を使用する:

```javascript
// 良い: 明確で説明的な命名
const variables = {
  projectName, // どのプロジェクトに取り組むか
  basePath, // プロジェクトファイルの保存場所
  outputDirectory, // 結果を保存する場所
  processingMode, // 処理方法（詳細レベル）
  configurationPath, // 設定ファイルの場所
};

// 避けるべきこと: 曖昧または矛盾
const bad_variables = {
  name, // 一般的すぎる
  path, // どのパスか不明
  mode, // 短すぎる
  config, // 曖昧すぎる
};
```

#### 3. **検証と制約**

有効な値と制約を文書化する:

```markdown
## 変数制約

**projectName**:

- Type: 文字列（英数字、ハイフン、アンダースコアが使用可能）
- Length: 1～100文字
- Required: yes
- Pattern: `/^[a-zA-Z0-9_-]+$/`

**processingMode**:

- Type: enum
- Valid values: "quick"（5分未満）、"standard"（5～15分）、"detailed"（15分以上）
- Default: "standard"
- Required: no
```

## MCP サーバー構成（組織/エンタープライズのみ）

MCPサーバーは追加ツールによってエージェントの機能を拡張します。組織レベルおよびエンタープライズレベルのエージェントでのみサポートされます。

### 設定形式

```yaml
---
name: my-custom-agent
description: "MCP統合エージェント"
tools: ["read", "edit", "custom-mcp/tool-1"]
mcp-servers:
  custom-mcp:
    type: "local"
    command: "some-command"
    args: ["--arg1", "--arg2"]
    tools: ["*"]
    env:
      ENV_VAR_NAME: ${{ secrets.API_KEY }}
---
```

### MCP サーバーのプロパティ

- **type**: サーバータイプ（`'local'` または `'stdio'`）
- **command**: MCPサーバーを起動するコマンド
- **args**: コマンド引数の配列
- **tools**: このサーバーから有効にするツール（すべて有効の場合は `["*"]`）
- **env**: 環境変数（シークレットをサポート）

### 環境変数とシークレット

シークレットは、「copilot」環境のリポジトリ設定で設定する必要があります。

**サポートされている構文**:

```yaml
env:
  # 環境変数のみ
  VAR_NAME: COPILOT_MCP_ENV_VAR_VALUE

  # ヘッダー付き変数
  VAR_NAME: $COPILOT_MCP_ENV_VAR_VALUE
  VAR_NAME: ${COPILOT_MCP_ENV_VAR_VALUE}

  # GitHub Actions スタイル（YAML のみ）
  VAR_NAME: ${{ secrets.COPILOT_MCP_ENV_VAR_VALUE }}
  VAR_NAME: ${{ var.COPILOT_MCP_ENV_VAR_VALUE }}
```

## ファイルの構成と命名

### リポジトリレベルのエージェント

- 場所: `.github/agents/`
- スコープ: 特定のリポジトリでのみ利用可能
- アクセス: リポジトリが設定された MCP サーバーを使用します

### 組織/エンタープライズレベルのエージェント

- 場所: `.github-private/agents/`（その後 `agents/` ルートに移動）
- 範囲: org/enterprise 内のすべてのリポジトリで利用可能
- アクセス: 専用の MCP サーバーを構成できます

### 命名規則

- ハイフン付きの小文字を使用します: `test-specialist.agent.md`
- 名前はエージェントの目的を反映する必要があります
- ファイル名はデフォルトのエージェント名になります（`name` が指定されていない場合）
- 使用できる文字: `.`、`-`、`_`、`a-z`、`A-Z`、`0-9`

## エージェントの処理と動作

### バージョン管理

- エージェントファイルのGitコミットSHAに基づく
- 異なるエージェントバージョン用のブランチ/タグを作成する
- リポジトリ/ブランチの最新バージョンを使用してインスタンス化されました
- PRインタラクションでは一貫性を保つために同じエージェントバージョンを使用します

### 名前の競合

優先度（最高から最低）:

1. リポジトリレベルのエージェント
2. 組織レベルのエージェント
3. エンタープライズレベルのエージェント

下位レベルの構成は、同じ名前の上位レベルの構成をオーバーライドします。

### ツール処理

- `tools` リストは利用可能なツール（組み込みおよび MCP）をフィルタリングします
- ツールが指定されていない = すべてのツールが有効
- 空のリスト (`[]`) = すべてのツールが無効
- 特定のリスト = 有効になっているツールのみ
- 認識されないツール名は無視されます（環境固有のツールを許可します）

### MCP サーバーの処理順序

1. すぐに使える MCP サーバー（例: GitHub MCP）
2. カスタム エージェント MCP 構成（組織/エンタープライズのみ）
3. リポジトリレベルのMCP構成

各レベルでは、前のレベルの設定を上書きできます。

## エージェント作成チェックリスト

### 前書き

- [ ] `description` フィールドが存在し、説明的である（50 ～ 150 文字）
- [ ] `description` は一重引用符で囲まれています
- [ ] `name` を指定（オプションだが推奨）
- [ ] `tools` が適切に設定されている（または意図的に省略されている）
- [ ] 最適なパフォーマンスを得るために`model`を指定
- [ ] 環境固有の場合は`target`を設定します
- [ ] 手動選択が必要な場合は`infer`を`false`に設定する

### プロンプト内容

- [ ] エージェントのアイデンティティと役割を明確に定義
- [ ] 主要な責任が明確に記載
- [ ] アプローチと方法論の説明
- [ ] 指定されたガイドラインと制約
- [ ] 出力期待を文書化
- [ ] 役立つ場合は例を示します
- [ ] 指示は具体的かつ実行可能である
- [ ] 範囲と境界が明確に定義されている
- [ ] 総コンテンツ数は30,000文字未満

### ファイル構造

- [ ] ファイル名は小文字とハイフンの規則に従います
- [ ] ファイルは正しいディレクトリ（`.github/agents/` または `agents/`）に配置されます
- [ ] ファイル名には許可された文字のみを使用します
- [ ] ファイル拡張子は `.agent.md` です

### 品質保証

- [ ] エージェントの目的は一意であり、重複しない
- [ ] ツールは最小限で必要なもの
- [ ] 指示は明確で曖昧さがない
- [ ] エージェントは代表的なタスクでテストされています
- [ ] ドキュメントの参照は最新です
- [ ] セキュリティ上の考慮事項（該当する場合）

## 一般的なエージェントパターン

### テストスペシャリスト

**目的**: テストの範囲と品質に重点を置く
**ツール**: すべてのツール（包括的なテスト作成用）
**アプローチ**: 分析し、ギャップを特定し、テストを記述し、本番環境のコード変更を回避する

### 実装プランナー

**目的**: 詳細な技術計画と仕様を作成する
**ツール**: `['read', 'search', 'edit']` に限定されます
**アプローチ**: 要件を分析し、ドキュメントを作成し、実装を回避する

### コードレビュー担当者

**目的**: コードの品質をレビューし、フィードバックを提供する
**ツール**: `['read', 'search']` のみ
**アプローチ**: 分析し、改善を提案するが、直接的な変更は行わない

### リファクタリングスペシャリスト

**目的**: コード構造と保守性を改善する
**ツール**: `['read', 'search', 'edit']`
**アプローチ**: パターンを分析し、リファクタリングを提案し、安全に実装する

### セキュリティ監査人

**目的**: セキュリティ上の問題と脆弱性を特定する
**ツール**: `['read', 'search', 'web']`
**アプローチ**: コードをスキャンし、OWASP に照らし合わせてチェックし、結果を報告します

## 避けるべきよくある間違い

### 前書きのエラー

- ❌ `description`フィールドがありません
- ❌ 説明が引用符で囲まれていない
- ❌ ドキュメントを確認せずに無効なツール名を使用している
- ❌ YAML構文が正しくありません（インデント、引用符）

### ツール設定の問題

- ❌ 不必要に過剰なツールアクセスを許可している
- ❌ エージェントの目的に必要なツールが不足している
- ❌ ツールエイリアスを一貫して使用していない
- ❌ MCP サーバーの名前空間を忘れています（`server-name/tool`）

### プロンプトコンテンツの問題

- ❌ 曖昧で不明瞭な指示
- ❌ 矛盾するガイドライン
- ❌ 明確な範囲定義の欠如
- ❌ 期待される成果が達成されていない
- ❌ 過度に詳細な指示（文字数制限を超える）
- ❌ 複雑なタスクの例やコンテキストがない

### 構成上の問題

- ❌ ファイル名はエージェントの目的を反映していません
- ❌ 間違ったディレクトリ（リポジトリと組織レベルの混同）
- ❌ ファイル名にスペースや特殊文字を使用する
- ❌ エージェント名の重複による競合の発生

## テストと検証

### 手動テスト

1. 適切な前書きでエージェントファイルを作成する
2. VS Code を再読み込みするか、GitHub.com を更新してください
3. Copilot Chatのドロップダウンからエージェントを選択します
4. 代表的なユーザークエリでテストする
5. ツールアクセスが期待どおりに機能することを確認する
6. 出力が期待どおりであることを確認する

### 統合テスト

- スコープ内の異なるファイルタイプを持つテストエージェント
- MCP サーバーの接続を確認する（構成されている場合）
- コンテキストが欠落しているエージェントの動作を確認する
- エラー処理とエッジケースをテストする
- エージェントの切り替えと引き継ぎを検証する

### 品質チェック

- エージェント作成チェックリストを実行する
- よくある間違いのリストを確認する
- リポジトリ内のサンプルエージェントと比較する
- 複雑なエージェントのピアレビューを取得する
- 特別な構成の必要性を文書化する

## 追加リソース

### 公式ドキュメント

- [Creating Custom Agents](https://docs.github.com/en/copilot/how-tos/use-copilot-agents/coding-agent/create-custom-agents)
- [Custom Agents Configuration](https://docs.github.com/en/copilot/reference/custom-agents-configuration)
- [Custom Agents in VS Code](https://code.visualstudio.com/docs/copilot/customization/custom-agents)
- [MCP Integration](https://docs.github.com/en/copilot/how-tos/use-copilot-agents/coding-agent/extend-coding-agent-with-mcp)

### コミュニティリソース

- [Awesome Copilot Agents Collection](https://github.com/github/awesome-copilot/tree/main/agents)
- [Customization Library Examples](https://docs.github.com/en/copilot/tutorials/customization-library/custom-agents)
- [Your First Custom Agent Tutorial](https://docs.github.com/en/copilot/tutorials/customization-library/custom-agents/your-first-custom-agent)

### 関連ファイル

- [プロンプトファイルのガイドライン](./prompt.instructions.md) - プロンプトファイルを作成する場合
- [指示ガイドライン](./instructions.instructions.md) - 指示ファイルを作成するため

## バージョン互換性に関する注意事項

### GitHub.com（コーディングエージェント）

- ✅ すべての標準的なフロントマタープロパティを完全にサポート
- ✅ リポジトリと組織/エンタープライズレベルのエージェント
- ✅ MCP サーバー構成（org/enterprise）
- ❌ `model`、`argument-hint`、`handoffs` プロパティをサポートしていません

### VS Code / JetBrains / Eclipse / Xcode

- ✅ AIモデル選択のための`model`プロパティをサポート
- ✅ `argument-hint` および `handoffs` プロパティをサポートします
- ✅ ユーザープロファイルとワークスペースレベルのエージェント
- ❌ リポジトリレベルでMCPサーバーを構成できません
- ⚠️ 一部のプロパティは異なる動作をする場合があります

複数の環境向けにエージェントを作成する場合は、共通プロパティに重点を置き、すべてのターゲット環境でテストを実施してください。必要に応じて、`target` プロパティを使用して環境固有のエージェントを作成してください。
