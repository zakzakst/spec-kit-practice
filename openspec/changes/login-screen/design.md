## コンテクスト

アプリケーションは現在、完全に認証なしの状態で動作しており、すべてのユーザーがすべてのルートと機能にアクセスできます。ユーザー固有のデータやセキュアな領域のサポートなど、要件が拡大するにつれて、認証メカニズムが必要になります。この変更により、ログイン画面と関連フローが導入されます。システムには、資格情報を確認するためのAPIエンドポイントが存在する（または提供される予定である）ことが想定されています。そのようなエンドポイントがまだ存在しない場合は、まずスタブ/モックを使用します。フロントエンドテクノロジーは、既存のプロジェクト構造に基づき、ReactベースのSPAです。

## 目標 / 非目標

**目標:**

- ユーザー名/メール アドレスとパスワード フィールドを備えたユーザー向けのログイン ページを提供します。
- クライアント側で入力を検証し、エラーを表示します。
- バックエンド API を介して資格情報を認証し、セッション/トークンを確立します。
- 認証されていないユーザーが保護されたルートにアクセスしようとしたときに、ログインにリダイレクトします。
- 将来的にサインアップやパスワード回復を簡単に拡張できるようにします。

**非目標:**

- ユーザー登録またはパスワード リセット ワークフローを実装します (これらは別の機能に属します)。
- 既存の API を使用するだけでなく、バ​​ックエンドの認証メカニズムを設計または変更します。
- OAuth/SSO または外部プロバイダーをサポートします。範囲内には基本的な資格情報チェックのみが含まれます。
- 既存のアプリ規則によって処理されるメモリ内/トークン ストレージを超えてセッション データを保持します。

## 決定

1. **セッション管理戦略**
   - _選択_: 簡潔にするために、安全な http 専用 Cookie (推奨) または localStorage に保存されている JWT トークンをフォールバックとして使用します。
   - _理由_: CookieはXSSに対するより優れた保護を提供します。ただし、バックエンドがまだCookieに対応していない場合は、localStorageを使用すると初期のイテレーションが簡素化されます。まずはlocalStorageから始め、サーバーがhttpのみのCookieをサポートしたらリファクタリングします。
   - _検討された代替案_: 完全な OAuth フロー (重すぎる)、セッションを Redux ストアにのみ保存 (リロードすると保持されない)。

2. **ルーティングの強制**
   - _選択_: 保護されたルートを、認証状態をチェックし、認証がない場合はログインにリダイレクトする高次コンポーネントまたはフック (`useAuth`) でラップします。
   - _理由_: ルート定義をクリーンな状態に保ち、ロジックを集中管理します。
   - _検討される代替案_: 各ページ コンポーネント内のリダイレクト ロジック (エラーが発生しやすい) またはサーバー側の強制 (SPA では適用されません)。

3. **フォームライブラリ**
   - _選択_: フォーム ライブラリ (Formik など) を取り込むのではなく、シンプルなハンドラーでネイティブの React 状態を使用します。
   - _理由_: ログイン フォームは非常にシンプルなので、追加の依存関係は不要です。

4. **エラー処理**
   - _Choice_: 検証の場合はインライン エラー メッセージを表示し、認証失敗の場合は一般的なバナー メッセージを表示します。
   - _理由_: 既存の UI パターンと一致している。

## リスク/トレードオフ

- **[リスク]** トークンを localStorage に保存すると、JavaScript に公開され、XSS のリスクが高まります。→ _軽減策_: すべての入力をサニタイズし、バックエンドがサポートしている場合は http のみの Cookie への移行を計画します。
- **[リスク]** 認証チェックが誤って構成されている場合（例：ログインページ自体に認証が必要な場合）、リダイレクトがループします。→ _軽減策_：ログインルートをパブリックとして明確にマークし、e2e テストで徹底的にテストします。
- **[リスク]** バックエンド API に未定義の動作や遅延が発生し、UX が低下する可能性があります。→ _軽減策_: 読み込みインジケーターとタイムアウト/再試行ロジックを実装します。

## 移行計画

1. 既存のコードベースに加えて、ログイン コンポーネントと認証ユーティリティを追加します。
2. ログインを含むすべてのルートを開いたままにするフロントエンド更新をデプロイします (リダイレクト ロジックは、機能フラグまたは構成によってオンにすることができます)。
3. まだ存在しない場合は、バックエンド チームと調整して `/api/login` エンドポイントを公開します。
4. バックエンドが Cookie ベースのセッションをサポートしたら、認証フックを更新し、トークン ストレージを localStorage から Cookie に移動します。
5. 保護されたルート ラッパーを展開し、重要でないルートから段階的にリダイレクトを有効にします。
6. ユーザーの問題を監視し、機能フラグを元に戻すか、以前のフロントエンドをデプロイすることでロールバックを提供します。

## 未解決の質問

- バックエンドはすでにログインエンドポイントを提供していますか？また、どのような応答形式を使用していますか？(JWT、セッション Cookie など)
- ログイン画面に「Remember me」チェックボックスを含める必要がありますか? 含める場合、トークンの有効期限にどのような影響がありますか?
- ログイン ページのレイアウトにはスタイル ガイドラインやブランド要件はありますか?
